
README file for lexical analyser 
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------



Keywords
------------
Most of the keywords in cool are case insensitive so most of the keywords we use following pattern
(?i:pattern)    i- case insensitive

EX-:	CLASS		(?i:class)
		ELSE		(?i:else)
		IF		(?i:if)

there are some special cases in keyword defining
In true and false, first letter must simple and other can be capital or simple 
			
			TRUE		t(?i:rue)	
			FALSE		f(?i:alse)

Integers
------------
Integers in cool comtaion 0-9 numbers but can not be null -    [0-9]+
After the patern [0-9]+ is matched, the matched string is added to the table of integers. 
Although table had a seperate function to add integers, here function of adding strings has been used. 
That is because how add_int() function work is by converting integer to string and calling add_string() internally. 
To avoid overhead add_string() has been directly used.

Identifiers
------------
Identifiers are strings (other than keywords) consisting of letters, digits, and the underscore character. 
In cool there are two type of identifiers
		type identifiers start with capital letter and rest can be any so it is define as [A-Z][A-Za-z0-9_]*
		object identifiers start with simple letter and res can be anyso it is define as [a-z][A-Za-z0-9_]*
One issue in implementing was all keywords are satisfying the conditions for the identifiers as well. 
It was solved by placing the patterns for keywords before the patterns for identifiers.

Line numbers
------------  
The integer variable curr_lineno strores the count of the number of lines. When a newline character is identified, that variable is incremented.

Rule Defining
--------------
In rule section for define keywords we ruturn relevent token class

	Ex:			{NEW}	{
					return NEW;
				}

				{CLASS} {
					return CLASS;
				}

for some token classes we pass valus for that tokens. (INT_CONST,Ture,False,TypeID,Object ID )

	Ex:
			{INT_CONST} {
				cool_yylval.symbol = inttable.add_string(yytext);
				return INT_CONST;
			}


			{INT_CONST} {
				cool_yylval.symbol = inttable.add_string(yytext);
				return INT_CONST;
			}


Comments
--------

There are two types of comments in COOL.

1. Single line comments - starts with '--'. To identify the regular expression "--".* was used. The regular expression of 
		character '.' matches all characters except '\n'. And, '.' will also match also allow 
		unprintable characters, even null characters, which is allowed in COOL comments.

2. Multiline Comments - Enclosed within "(*" and "*)". Since COOL allows nested multiline comments, same technique used in single line comments
		can not be used. When a "(*" is catched, the lexer goes into anexclusive state 'COMMENT'. Variable comment_depth keeps track of the depth of 
		nested comments. comment_depth is incremented when "(*" is appeared and decremented when "*)" is appeared. When the comment_depth becomes 
		zero the lexer goes back to the INITIAL state. When a '\n' is appeared in the comment, the line number counter 
		'curr_lineno' is incremented. All other characters are ignored. When an EOF is encountered within the comment, an error 
		flag is returned with the error message.


<INITIAL>"*)"  	->error

							return error when there is are comment ending in initial state. (comment ending without comment begining) 

<INITIAL>{COMMENT_START}
							go to comment state. increase comment depath. Depth can use to fined all the comments brackets are close. when close(depth==0)

<comment>{COMMENT_START} 	
							nested comment. depth increse

<comment>\n	
							new line inside comment. increase line number

<comment>"*)" 		

							closeing comment. compaire depth to find out all the comments are close

<comment><<EOF>> -> error

							comment bracket is not close. return error		

"--".*	{  }				
							single line comment. not need to jump to a new stte since it is a single line


Strings
-------

In cool, strings are enclosed in double quotes("....")
when we start string we go to a another state called string, in the same time 
is_broken string=0
string_length=0
is_broken is use to find null characters in string if there is null it became 1
string_length is use to compire string length with maxstring length
memset function create null string buffers whith size of max string length 
when a string with is_broken string=0 and less than max string len. It give STR_CONST token.

It goes back to the 'INITIAL' state when it encounters an unescaped '"'. A string	buffer is 
maintained where all the character in the string are added.

If the lexer encounters an escaped n, b, t, or f, it adds the associated special character to the string buffer. For all other 
escaped characters, the character itself is added to the buffer. When unescaped, the string is considered to be unterminated, the lexer 
goes to the 'INITIAL' state. When the newline is escaped, a newline character is added to the string 
buffer. 
Either it is escaped or not, a null character is not allowed in a COOL string constant. When it is appeaared, the lexer moves to another state 
'IGNORE_STRING'. In this state all character except newlines and 
quotes are ignored. When EOF is encountered when in the 'STRING' state, an error flag is raised.
Maximum length of string constant is 1024 characters. Therefore, when a new character is added to the string buffer, it is checked with the maximum allowed length. If the string exceed the length, an error is given and the lexer enters the 'IGNORE_STRING' state.

{STRING_START}		{ BEGIN(string); is_broken_string = 0; string_length = 0; extra_length = 0; memset(&string_buf, 0, MAX_STR_CONST); }


In cool dose not contain null strings. if se we want to pass error 
		<string>"\"" ->error

"\",\n,\t,\f,\b for these escape characters we incraese the string length by one.
multi line strings can be proforn with \ at the end
	"This is \
	OK"

for put \ in side the string we use
		<string>"\\\\"		{ string_buf[string_length++] = '\\'; }


<string>[\0]		{   
				is_broken_string = 1;
  				cool_yylval.error_msg = "String contains null character";
				return ERROR;
			}

<string>\\\0		{   
				is_broken_string = 1;
  				cool_yylval.error_msg = "String contains escaped null character.";
				return ERROR;
			}

	The uppere code use to find null characters inside string. If it is, return error

<string><<EOF>>	-> error   if string has no ending " then return error


\n	{ curr_lineno++; }  take as go to a new lone

.	{ cool_yylval.error_msg = strdup(yytext); return ERROR; } if any whith ou define upper is taken as error

Multiple character constants
-----------------------------
In cool there are 3 multiple character operations
DARROW =>
ASSING <-
LE <=

When these are appeared, the associated constants are returned. When the allowed single character constants are appeared, the 
character itself is returned.

String constant
----------------

.,;,,,),(,{,},<,),:,=,+,-,~,@,* are taken as tokens

White-spaces
----------------
	space(' '), newline('\n'), formfeed('\f'), carriage return('\r'), horizontal tab('\t') and vertical tab('\v') as 
	considered as whitespace characters in COOL and these are ignore by the lexer.

Test cases
----------------
Various test cases to test the lexer has been implemented and contains in folder Tests. Different types of error cases and 
combine errors has been implemented and tested. 





